#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "tinyusb.h"
#include "class/hid/hid_device.h"

static const char *TAG = "R-SODIUM Controller";
#define REPORT_SIZE 64
// #define LED_GPIO GPIO_NUM_1 // GPIO1
#define LED_GPIO_MASK ((1ULL << GPIO_NUM_1) | (1ULL << GPIO_NUM_2) | (1ULL << GPIO_NUM_3) | (1ULL << GPIO_NUM_4))



// HID 报告描述符
const uint8_t hid_report_descriptor[] = {
    TUD_HID_REPORT_DESC_GENERIC_INOUT(REPORT_SIZE)
};

// 配置描述符
#define TUSB_DESC_TOTAL_LEN (TUD_CONFIG_DESC_LEN + TUD_HID_DESC_LEN)
static const uint8_t hid_configuration_descriptor[] = {
    TUD_CONFIG_DESCRIPTOR(1, 1, 0, TUSB_DESC_TOTAL_LEN, 0x00, 100),
    TUD_HID_DESCRIPTOR(0, 0, false, sizeof(hid_report_descriptor), 0x81, REPORT_SIZE, 10),
};

// HID 描述符回调
uint8_t const *tud_hid_descriptor_report_cb(uint8_t instance) {
    return hid_report_descriptor;
}

// 主机读取 HID 报告（不使用）
uint16_t tud_hid_get_report_cb(uint8_t instance,
                                uint8_t report_id,
                                hid_report_type_t report_type,
                                uint8_t *buffer,

                                uint16_t reqlen) {
    return 0;
}

void init_nvs() {
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        nvs_flash_erase();
        nvs_flash_init();
    }
}

void save_gpio_state(uint8_t gpio_num, uint8_t value) {
    nvs_handle_t nvs_handle;
    char key[16];
    snprintf(key, sizeof(key), "gpio_%d", gpio_num);

    if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
        nvs_set_u8(nvs_handle, key, value);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }
}

void nvs_save(char _type, uint8_t value) {
    nvs_handle_t nvs_handle;
    char key[16];
    snprintf(key, sizeof(key), _type);

    if (nvs_open("storage", NVS_READWRITE, &nvs_handle) == ESP_OK) {
        nvs_set_u8(nvs_handle, key, value);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }
}

void restore_gpio_state(uint8_t gpio_num) {
    nvs_handle_t nvs_handle;
    uint8_t value = 0;
    char key[16];
    // 修复：snprintf 第一个参数应为目标缓冲区
    snprintf(key, sizeof(key), "gpio_%d", gpio_num);

    esp_err_t ret = nvs_open("storage", NVS_READONLY, &nvs_handle);
    if (ret == ESP_OK) {
        if (nvs_get_u8(nvs_handle, key, &value) == ESP_OK) {
            gpio_set_level(gpio_num, value);
            ESP_LOGI(TAG, "Restored GPIO %d to value: %d", gpio_num, value);
        } else {
            gpio_set_level(gpio_num, 0);
            ESP_LOGW(TAG, "No saved state for GPIO %d, set to 0", gpio_num);
            save_gpio_state(gpio_num, 0); // 确保在 NVS 中保存默认状态
            ESP_LOGI(TAG, "Default state saved for GPIO %d", gpio_num);
        }
        nvs_close(nvs_handle);
    } else {
        gpio_set_level(gpio_num, 0);
        ESP_LOGE(TAG, "NVS open failed (0x%x): GPIO %d set to 0", ret, gpio_num);
        save_gpio_state(gpio_num, 0); // 确保在 NVS 中保存默认状态
        ESP_LOGI(TAG, "Default state saved for GPIO %d", gpio_num);
    }
}

void tud_hid_set_report_cb(uint8_t instance,
                           uint8_t report_id,
                           hid_report_type_t report_type,
                           uint8_t const *buffer,
                           uint16_t bufsize) {
    ESP_LOGI(TAG, "Received from host: %d bytes", bufsize);
    if (bufsize > 0) {
        switch (buffer[0])
        {
        case 0x01: // LED ON
            gpio_set_level(GPIO_NUM_1, 1);
            save_gpio_state(GPIO_NUM_1, 1);
            ESP_LOGI(TAG, "LED1 ON");
            break;
        case 0x02:
            gpio_set_level(GPIO_NUM_2, 1);
            save_gpio_state(GPIO_NUM_2, 1);
            ESP_LOGI(TAG, "LED2 ON");
            break;
        case 0x03:
            gpio_set_level(GPIO_NUM_3, 1);
            save_gpio_state(GPIO_NUM_3, 1);
            ESP_LOGI(TAG, "LED3 ON");
            break;
        case 0x04:
            gpio_set_level(GPIO_NUM_4, 1);
            save_gpio_state(GPIO_NUM_4, 1);
            ESP_LOGI(TAG, "LED4 ON");
            break;
        default:
            gpio_set_level(GPIO_NUM_1, 0);
            gpio_set_level(GPIO_NUM_2, 0);
            gpio_set_level(GPIO_NUM_3, 0);
            gpio_set_level(GPIO_NUM_4, 0);
            save_gpio_state(GPIO_NUM_1, 0);
            save_gpio_state(GPIO_NUM_2, 0);
            save_gpio_state(GPIO_NUM_3, 0);
            save_gpio_state(GPIO_NUM_4, 0);
            ESP_LOGI(TAG, "LEDs OFF");
            break;
        }
    }

    // Echo 回传
    if (tud_hid_ready()) {
        tud_hid_report(0, buffer, bufsize);
    }
}

void clear_nvs_all() {
    esp_err_t err;
    err = nvs_flash_erase();
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "NVS erased successfully.");
    }

    err = nvs_flash_init();
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "NVS re-initialized.");
    }
}

void app_main(void) {
    ESP_LOGI(TAG, "R-SODIUM Ultra SSD Enclosure Controller Start");

    init_nvs();

    gpio_config_t io_conf = {
        .pin_bit_mask = LED_GPIO_MASK,
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&io_conf);
    
    restore_gpio_state(GPIO_NUM_1);
    restore_gpio_state(GPIO_NUM_2);
    restore_gpio_state(GPIO_NUM_3);
    restore_gpio_state(GPIO_NUM_4);

    // clear_nvs_all();

    const tinyusb_config_t tusb_cfg = {
        .device_descriptor = NULL,
        .configuration_descriptor = hid_configuration_descriptor,
        .string_descriptor = NULL,
        .external_phy = false,
    };
    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));
    ESP_LOGI(TAG, "Controller initialized");

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}